<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/11.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="sample.SourceCodeWindowController">
   <children>
      <TextArea fx:id="CodeArea" editable="false" layoutY="42.0" prefHeight="308.0" prefWidth="600.0" text="........................................................  Insertion Sort  .........................................................&#10;     &#10;procedure insertionSort( A : array of items )&#10;   int holePosition&#10;   int valueToInsert&#10;&#10;   for i = 1 to length(A) inclusive do:&#10;&#10;      /* select value to be inserted /&#10;      valueToInsert = A[i]&#10;      holePosition = i&#10;&#10;      /locate hole position for the element to be inserted /&#10;&#10;      while holePosition &gt; 0 and A[holePosition-1] &gt; valueToInsert do:&#10;         A[holePosition] = A[holePosition-1]&#10;         holePosition = holePosition -1&#10;      end while&#10;&#10;      / insert the number at hole position */&#10;      A[holePosition] = valueToInsert&#10;&#10;   end for&#10;&#10;end procedure&#10;&#10;&#10;........................................................  Selection Sort  .........................................................&#10;&#10;procedure selection sort &#10;   list  : array of items&#10;   n     : size of list&#10;&#10;   for i = 1 to n - 1&#10;   /* set current element as minimum/&#10;      min = i&#10;&#10;      / check the element to be minimum /&#10;&#10;      for j = i+1 to n &#10;         if list[j] &lt; list[min] then&#10;            min = j;&#10;         end if&#10;      end for&#10;&#10;      / swap the minimum element with the current element*/&#10;      if indexMin != i  then&#10;         swap list[min] and list[i]&#10;      end if&#10;   end for&#10;&#10;end procedure&#10;&#10;&#10;........................................................  Quick Sort  .........................................................&#10;&#10;function partitionFunc(left, right, pivot)&#10;   leftPointer = left&#10;   rightPointer = right - 1&#10;&#10;   while True do&#10;      while A[++leftPointer] &lt; pivot do&#10;         //do-nothing&#10;      end while&#10;&#10;      while rightPointer &gt; 0 &amp;&amp; A[--rightPointer] &gt; pivot do&#10;         //do-nothing&#10;      end while&#10;&#10;      if leftPointer &gt;= rightPointer&#10;         break&#10;      else&#10;         swap leftPointer,rightPointer&#10;      end if&#10;&#10;   end while &#10;&#10;   swap leftPointer,right&#10;   return leftPointer&#10;&#10;end function&#10;&#10;procedure quickSort(left, right)&#10;&#10;   if right-left &lt;= 0&#10;      return&#10;   else&#10;      pivot = A[right]&#10;      partition = partitionFunc(left, right, pivot)&#10;      quickSort(left,partition-1)&#10;      quickSort(partition+1,right)&#10;   end if&#10;&#10;end procedure&#10;&#10;&#10;........................................................  Bubble Sort  .........................................................&#10;&#10;procedure bubbleSort( list : array of items )&#10;&#10;   loop = list.count;&#10;&#10;   for i = 0 to loop-1 do:&#10;      swapped = false&#10;&#10;      for j = 0 to loop-1 do:&#10;&#10;         /* compare the adjacent elements /&#10;         if list[j] &gt; list[j+1] then&#10;            / swap them /&#10;            swap( list[j], list[j+1] )&#10;            swapped = true&#10;         end if&#10;&#10;      end for&#10;&#10;      /if no number was swapped that means &#10;      array is sorted now, break the loop.*/&#10;&#10;      if(not swapped) then&#10;         break&#10;      end if&#10;&#10;   end for&#10;&#10;end procedure return list&#10;&#10;&#10;........................................................  Merge Sort  .........................................................&#10;&#10;procedure mergesort( var a as array )&#10;   if ( n == 1 ) return a&#10;&#10;   var l1 as array = a[0] ... a[n/2]&#10;   var l2 as array = a[n/2+1] ... a[n]&#10;&#10;   l1 = mergesort( l1 )&#10;   l2 = mergesort( l2 )&#10;&#10;   return merge( l1, l2 )&#10;end procedure&#10;&#10;procedure merge( var a as array, var b as array )&#10;&#10;   var c as array&#10;   while ( a and b have elements )&#10;      if ( a[0] &gt; b[0] )&#10;         add b[0] to the end of c&#10;         remove b[0] from b&#10;      else&#10;         add a[0] to the end of c&#10;         remove a[0] from a&#10;      end if&#10;   end while&#10;&#10;   while ( a has elements )&#10;      add a[0] to the end of c&#10;      remove a[0] from a&#10;   end while&#10;&#10;   while ( b has elements )&#10;      add b[0] to the end of c&#10;      remove b[0] from b&#10;   end while&#10;&#10;   return c&#10;&#10;end procedure&#10;&#10;" AnchorPane.bottomAnchor="50.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="45.0" />
      <Button fx:id="OkButton" layoutX="269.0" layoutY="340.0" mnemonicParsing="false" onAction="#OkButtonPressed" prefHeight="18.0" prefWidth="62.0" text="Ok" AnchorPane.bottomAnchor="10.0" />
      <Label layoutX="235.0" layoutY="14.0" text="Source Code" AnchorPane.topAnchor="10.0">
         <font>
            <Font size="20.0" />
         </font></Label>
   </children>
</AnchorPane>
